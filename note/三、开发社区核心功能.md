## 开发社区核心功能

#### 一：过滤敏感词

- 前缀树
  - 名称：Trie，字典树，查找树
  - 特点：查找效率高，消耗内存大
  - 应用：字符串检索，词频统计，字符串排序等
- 敏感词过滤器
  - 定义前缀树
  - 根据敏感词，初始化前缀树
  - 编写过滤敏感词的方法

敏感词过滤器功能的实现：https://github.com/jinrunheng/sensitive-words-filter

大家可以直接导入 maven 依赖使用：
```xml
<dependency>
  <groupId>io.github.jinrunheng</groupId>
  <artifactId>sensitive-words-filter</artifactId>
  <version>0.0.1</version>
</dependency>

```

#### 二：发布帖子

- AJAX

  - Asynchronous JavaScript and XML
  - 异步的JavaScript与XML，不是一门新的技术，只是一个新的术语
  - 使用AJAX，网页能够将增量更新呈现在页面上，而不需要刷新整个页面
  - 虽然X代表XML，但是目前JSON的使用比XML更加普遍
  - 文档：https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX

- 示例

  - 使用jQuery发送AJAX请求

    Controller:

    ```java
    		@RequestMapping(path = "ajax",method = RequestMethod.POST)
        @ResponseBody
        public String testAjax(String name,int age){
            // 0 代表成功 {"code":"0","msg":"操作成功"}
            return CommunityUtil.getJSONString(0,"操作成功");
        }
    ```

    Ajax:

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>AJAX</title>
    </head>
    <body>
    <p>
        <input type="button" value="发送" onclick="send();">
    </p>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" crossorigin="anonymous"></script>
    <script>
        // 使用jQuery 发送一个异步请求
      	// 按照如下格式发送一个Ajax异步请求
      	// 1. 访问路径 
      	// 2. 传入的数据 如示例中，传入的数据为{"name":"张三","age":"23"}，提交方式为post
        // 3. 回调函数 controller返回的为JSON格式的字符串，回调函数将JSON字符串变成一个对象异步返回给页面
        function send() {
            $.post(
                "/community/alpha/ajax",
                {"name":"张三","age":"23"},
                function (data) {
                    console.log(typeof(data)) //  string
                    console.log(data) // {"code":0,"msg":"操作成功"}
    
                    data = $.parseJSON(data) 
                    console.log(typeof(data)) // object
                    console.log(data.code)
                    console.log(data.msg)
                }
            );
        }
    </script>
    </body>
    </html>
    ```

- 实践

  - 采用AJAX请求，实现发布帖子的功能


- 效果演示

登陆后，在首页点击我要发布

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1greo68xk3qj30vr0u0teu.jpg" alt="image-20210611215525707" style="zoom:50%;" align="left"/>



输入标题以及正文后，点击我要发布

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1greo7zgks1j30z90u0763.jpg" alt="image-20210611215717522" style="zoom:50%;" align="left"/>

发布成功后，回到首页并弹出提示框显示发布成功

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1greo8yjaepj30w20u079p.jpg" alt="image-20210611215800845" style="zoom:50%;" align="left" />

#### 三：帖子详情

- DiscussPostMapper
- DiscussPostService
- DiscussPostController
- Index.html
  - 在帖子标题上增加访问详情页面的链接
- discuss-detail.html
  - 处理静态之源的访问路径
  - 复用index.html的header区域
  - 显示标题，作者，发布时间，帖子正文等内容

- 效果演示：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1greo12qfxtj30x70u0n2y.jpg" alt="image-20210611215039655" style="zoom:50%;" align="left"/>

在首页点击帖子，可以链接到帖子详情页

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1greo2z1oi5j30vi0u0n33.jpg" alt="image-20210611215222293" style="zoom:50%;" align="left"/>

详情页中可以正常显示用户头像，帖子 title，content，以及创建时间。

#### 四：事务管理

- 什么是事务
  - 事务是由N步数据库操作序列组成的逻辑执行单元，这系列操作要么全执行，要么全放弃执行
- 事务的特性(ACID)
  - 原子性(Atomicity):事务是应用中不可再分的最小执行体。
  - 一致性(Consistency):事务执行的结果，须使数据从一个一致性状态，变为另一个一致性状态。
  - **隔离型(Isolation)**：各个事务的执行互不干扰，任何事务的内部操作对其他的事物都是隔离的。(多线程，并发的时候互不干扰)
  - 持久性(Durability)：事务一旦提交，对数据所做的任何改变都要记录到永久存储器中。

##### 事务的隔离性

- 常见的并发异常
  - 第一类丢失更新，第二类丢失更新。
  - 脏读，不可重复读，幻读。
- 常见的隔离级别
  - Read Uncommitted: 读取未提交的数据 
  - Read Committed：读取已提交的数据
  - Repeatable Read：可重复读
  - Serializable：串行化



事务的隔离型常见的并发异常解释（**面试常考**）：

###### 1. 第一类丢失更新

某一个事务的回滚，导致另外一个事务已更新的数据丢失

| 时刻 | 事务1           | 事务2        |
| ---- | --------------- | ------------ |
| T1   | Read:N = 10     |              |
| T2   |                 | Read:N = 10  |
| T3   |                 | Write:N = 9  |
| T4   |                 | Commit:N = 9 |
| T5   | Write:N = 11    |              |
| T6   | Rollback:N = 10 |              |

###### 2. 第二类丢失更新

某一个事务的提交，导致另外一个事务已更新的数据丢失

| 时刻 | 事务1         | 事务2        |
| ---- | ------------- | ------------ |
| T1   | Read:N = 10   |              |
| T2   |               | Read:N = 10  |
| T3   |               | Write:N = 9  |
| T4   |               | Commit:N = 9 |
| T5   | Write:N = 11  |              |
| T6   | Commit:N = 11 |              |

###### 3. 脏读

某一个事务，读取了另外一个事务未提交的数据

| 时刻 | 事务1           | 事务2       |
| ---- | --------------- | ----------- |
| T1   | Read:N = 10     |             |
| T2   | Write:N = 11    |             |
| T3   |                 | Read:N = 11 |
| T4   | Rollback:N = 10 |             |

###### 4. 不可重复读

某一个事务，对同一个数据前后读取的结果不一致

| 时刻 | 事务1         | 事务2       |
| ---- | ------------- | ----------- |
| T1   | Read:N = 10   |             |
| T2   |               | Read:N = 10 |
| T3   | Write:N = 11  |             |
| T4   | Commit:N = 11 |             |
| T5   |               | Read:N = 11 |

###### 5. 幻读

某一个事务，对同一个表前后查询到的行数不一致

| 时刻 | 事务1              | 事务2                    |
| ---- | ------------------ | ------------------------ |
| T1   |                    | Select:id < 10 (1,2,3)   |
| T2   | Insert:id = 4      |                          |
| T3   | Commit:id(1,2,3,4) |                          |
| T4   |                    | Select:id < 10 (1,2,3,4) |



##### 事务的隔离级别

| 隔离级别         | 第一类丢失更新 | 脏读 | 第二类丢失更新 | 不可重复读 | 幻读 |
| ---------------- | -------------- | ---- | -------------- | ---------- | ---- |
| Read Uncommitted | Y              | Y    | Y              | Y          | Y    |
| Read Committed   | N              | N    | Y              | Y          | Y    |
| Repeatable Read  | N              | N    | N              | N          | Y    |
| Serializable     | N              | N    | N              | N          | N    |

##### 数据库保障事务的机制

实现机制

###### 1. 悲观锁(数据库)

- 共享锁(S锁)
  - 事务A对某数据加了共享锁后，其他事务职能对该数据加共享锁，但不能加排他锁头
- 排它锁(X锁)
  - 事务A对某数据加了排他锁后，其他事务对该数据既不能加共享锁，也不能加排他锁。

###### 2. 乐观锁(自定义)

- 版本号，时间戳等
  - 在更新数据前，检查版本号是否发生变化。若发生变化则取消本次更新，否则就更新数据(版本号 + 1)



##### Spring事务管理

###### 1. 声明式事务

- 通过XML配置，声明某方法对事务特征。
- 通过注解(@Transactional)，声明某方法对事务特征。

###### 2. 编程式事务

- 通过TransactionTemplate 管理事务
- 并且通过TransactionTemplate执行数据库操作

##### 事务传播特性

###### 1. REQUIED

默认的传播特性，业务方法需要在一个事务中运行，如果一个方法已经处在一个事务中，那么就加入到这个事务，否则就会创建一个事务

###### 2. NEVER

指定的业务方法绝对不能在事务范围内运行，如果业务方法在某个事务中执行，就会抛出异常，只有业务方法没有任何事务才执行。

###### 3. MANDATORY

该属性指定业务方法只能在一个已经存在的事务中执行，业务方法不能自己发起自己的事务，如果业务方法不存在事务，容器就会抛出异常。

###### 4. SUPPORTS

如果业务方法中已经在某个事务中被调用，则方法就称为事务的一部分，如果外部业务方法没有开启事务，supports该方法也会在没有事务的环境中执行。

###### 5. NOT_SUPPORTED

如果该业务方法在一个事务中被调用，那么当前的事务会被挂起，执行该业务方法，方法执行完毕唤醒被挂起的事务，如果业务方法不在一个事务中执行，该方法也不会开事务。不管是否在有无事务的环境中执行都不开启事务。

###### 6. REQUIRES_NEW

不管是否存在事务，业务方法总会自己开启一个事务，如果在已有事务的环境中调用，已有事务会被挂起，新的事务会被创建，直到业务方法调用结束，已有事务才被唤醒。

###### 7. NESTED

如果业务方法在一个事务中执行，就在这个事务中嵌套，如果没有事务按着required执行，开启单独的事务，这种事务有多个事务的保存点，内部事务的回滚对外部事务没有影响。



##### 示例

###### 1. 声明式事务示例

```java

    @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)
    public Object save1() {
        // 新增用户
        User user = new User();
        user.setUsername("alpha");
        user.setSalt(CommunityUtil.generateUUID().substring(0, 5));
        user.setPassword(CommunityUtil.md5("123" + user.getSalt()));
        user.setEmail("alpha@qq.com");
        user.setHeaderUrl("http://image,nowcoder.com/head/99.png");
        user.setCreateTime(new Date());

        userMapper.insertUser(user);

        // 新增帖子
        DiscussPost post = DiscussPost.builder()
                .id(999)
                .userId(user.getId())
                .title("Hello")
                .content("新人报道~")
                .createTime(new Date())
                .build();
        discussPostMapper.insertDiscussPost(post);

        // 人为制造一个错误 会返回 NumberFormatException 
        Integer.valueOf("abc");
        return "ok";
    }
```

测试程序：

```java
		@Test
    public void testSave1() {
        Assertions.assertThrows(NumberFormatException.class,()->{
            alphaService.save1();
        });

        // 数据会回滚，所以用户和帖子都不会插入到对应的数据库中
        Assertions.assertNull(userService.findUserByEmail("alpha@qq.com"));
        Assertions.assertNull(discussPostService.findDiscussPostById(999));
    }
```



###### 2. 编程式事务示例

```java
		public Object save2() {
        transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
        transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        return transactionTemplate.execute((TransactionCallback<Object>) transactionStatus -> {
            // 新增用户
            User user = new User();
            user.setUsername("beta");
            user.setSalt(CommunityUtil.generateUUID().substring(0, 5));
            user.setPassword(CommunityUtil.md5("123" + user.getSalt()));
            user.setEmail("beta@qq.com");
            user.setHeaderUrl("http://image,nowcoder.com/head/66.png");
            user.setCreateTime(new Date());

            userMapper.insertUser(user);

            // 新增帖子
            DiscussPost post = DiscussPost.builder()
                    .id(666)
                    .userId(user.getId())
                    .title("Hello")
                    .content("新人报道~")
                    .createTime(new Date())
                    .build();
            discussPostMapper.insertDiscussPost(post);

            // 人为制造一个错误
            Integer.valueOf("abc");
            return "ok";
        });
    }
```

测试程序

```java
		@Test
    public void testSave2() {
        Assertions.assertThrows(NumberFormatException.class,()->{
            alphaService.save2();
        });

        // 数据会回滚，所以用户和帖子都不会插入到对应的数据库中
        Assertions.assertNull(userService.findUserByEmail("beta@qq.com"));
        Assertions.assertNull(discussPostService.findDiscussPostById(666));
    }
```



#### 五：显示评论

- 数据层
  - 根据实体查询一页评论数据
  - 根据实体查询评论
- 业务层
  - 处理查询评论的业务
  - 处理查询评论数量的业务
- 表现层
  - 显示帖子详情数据时，同时显示该帖子所有的评论数据



- 效果演示

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgxboav3uj30ul0u00zz.jpg" alt="image-20210613204318738" style="zoom:50%;" align="left"/>

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgxdnmhqhj31260u0q6l.jpg" alt="image-20210613204520810" style="zoom:50%;" align="left"/>



#### 六：添加评论

- 数据层
  - 添加评论数据
  - 修改帖子的评论数量
- 业务层
  - 处理添加评论的业务
  - 先增加评论，再更新帖子的评论数量
- 表现层
  - 处理添加评论数据的请求
  - 设置添加评论的表单
- 效果演示

可以针对帖子进行评论

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgzx4ejrsj31490u0q5c.jpg" alt="image-20210613221318124" style="zoom:50%;" align="left"/>

可以针对帖子进行回复

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgzyve1lbj31cp0u0779.jpg" alt="image-20210613221448417" style="zoom:50%;" align="left"/>

可以针对帖子的回复进行回复

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grh0wn9sm1j31gk0u0whc.jpg" alt="image-20210613224714261" style="zoom:50%;" align="left"/>



#### 七：私信列表

- 私信列表

  - 查询当前用户的会话列表，每个会话只显示一条最新的私信。
  - 支持分页显示
- 私信详情

  - 查询某个会话所包含的私信
  - 支持分页显示
- 数据表的设计

  - 字段：`id`,`from_id`,`to_id`,`conversation_id`,`content`,`status`,`create_time`
  - `conversation_id`  一段会话的id：例如`from_id:111`,`to_id:112`;那么`conversation_id`即为：`111_112`（小的在前）
  - `status` 0代表未读，1代表已读，2代表删除

- 效果演示

私信列表页：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gri390lnf7j310i0u044m.jpg" alt="image-20210614205350808" style="zoom:50%;" align="left"/>

私信详情页

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gri3auds27j30wm0u0dlb.jpg" alt="image-20210614205535303" style="zoom:50%;" align="left"/>

#### 八：发送私信

- 发送私信
  - 采用异步的方式发送私信
  - 发送成功后刷新私信列表
- 设置已读
  - 访问私信详情时，将显示的私信设置为已读状态
- 效果演示

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gri6axnemhj31dd0u0wha.jpg" alt="image-20210614223932586" style="zoom:50%;" align="left"/>

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gri6c0mvlrj316k0u0myd.jpg" alt="image-20210614224023026" style="zoom:50%;" align="left"/>

也可以点进私信详情给私信对话的某人发私信

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gri6dkpcccj312l0u078t.jpg" alt="image-20210614224203784" style="zoom:50%;" align="left"/>

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gri6ew8leuj316o0u0dhk.jpg" alt="image-20210614224324112" style="zoom:50%;" align="left"/>

发送成功后，会在私信列表中，查看到发送到内容

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grj8s9u3xzj30wt0u0n2q.jpg" alt="image-20210615205057744" style="zoom:50%;" align="left"/>

对方登陆账号后，会看到未读消息提示

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grj8u33353j31hg0ksgo2.jpg" alt="image-20210615205240387" style="zoom:50%;" align="left"/>



点击私信内容后，消息会变成已读取的状态

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grj8v7666ij31hi0k676h.jpg" alt="image-20210615205353938" style="zoom:50%;" align="left"/>



#### 九：删除私信

删除私信功能：即点击某条私信的删除按钮时，将其状态设置为删除态

- Dao层

  Dao层不需要添加删除方法，updateStatus可以修改消息的状态，当status为2时，代表删除

  ```java
  int updateStatus(List<Integer> ids, int status);
  ```

- Service层

  删除消息

  ```java
  public int deleteMessage(int id) {
      return messageMapper.updateStatus(Arrays.asList(new Integer[]{id}), 2);
  }
  ```

- Controller层

  删除私信

  ```java
  		@RequestMapping(path = "/letter/delete", method = RequestMethod.POST)
      @ResponseBody
      public String deleteLetter(int id) {
          messageService.deleteMessage(id);
          return CommunityUtil.getJSONString(0);
      }
  ```

- 异步JS

  ```javascript
  function delete_msg() {
      var btn = this
      var id = $(btn).prev().val()
  
      // TODO 删除数据
      $.post(
          CONTEXT_PATH + "/letter/delete",
          {"id": id},
          function (data) {
              data = $.parseJSON(data);
              if (data.code == 0) {
                  $(this).parents(".media").remove();
                  location.reload(); // 用户删除掉一条私信消息，及时刷新页面，让用户看到结果
              } else {
                  alert(data.msg)
              }
          }
      )
  }
  ```

#### 十：统一处理异常

在 resources/templates/error 路径下，增加500.html 页面和 404.html页面

SpringBoot 会自动处理异常，重定向到对应的页面

如果输入一个错误的路径，那么会跳转到 404.html 页面

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grjb1oa8nwj31cm0u0wog.jpg" alt="image-20210615220911618" style="zoom:50%;" align="left"/>



如果服务器内部发生错误，那么会跳转到 500.html 页面

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grjb44axf9j31d20u0jyx.jpg" alt="image-20210615221128250" style="zoom:50%;" align="left"/>



对于服务器内部异常，我们可以使用 SpringBoot 为我们提供的注解来进行处理：

- @ControllerAdvice
  - 用于修饰类，表示该类是Controller的全局配置类
  - 在此类中，可以对Controller进行如下三种全局配置：
    - 异常处理方案
    - 绑定数据方案
    - 绑定参数方案
- @ExceptionHandler
  - 用于修饰方法，该方法会在Controller出现异常后被调用，用户处理捕获到的异常
- @ModelAttribute
  - 用于修饰方法，该方法会在Controller方法执行前被调用，用于为Model对象绑定参数

- @DataBinder
  - 用于修饰方法，该方法会在Controller方法执行前被调用，用于绑定参数的转换器

```java
@GetMapping("/error")
public String getErrorPage() {
    return "/error/500";
}
```

```java
package com.github.community.controller.advice;

import com.github.community.util.MyUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

// 只去扫描带有 Controller 注解的 Bean
@ControllerAdvice(annotations = Controller.class)
public class ExceptionAdvice {

    private static final Logger logger = LoggerFactory.getLogger(ExceptionAdvice.class);

    @ExceptionHandler({Exception.class})
    public void handleException(Exception e, HttpServletRequest request, HttpServletResponse response) throws IOException {
        logger.error("服务器发生异常: " + e.getMessage());
        for (StackTraceElement element : e.getStackTrace()) {
            logger.error(element.toString());
        }

        String xRequestedWith = request.getHeader("x-requested-with");
        // 如果是一个异步请求发生的异常（带有 @ResponseBody 注解的 Controller）
        if ("XMLHttpRequest".equals(xRequestedWith)) {
            response.setContentType("application/json;charset=utf-8");
            PrintWriter writer = response.getWriter();
            writer.write(MyUtil.getJSONString(1, "服务器异常"));
        } else {
            // 如果不是异步请求，就重定向到 error 页面
            response.sendRedirect(request.getContextPath() + "/error");
        }
    }
}

```



#### 十一：统一记录日志

##### AOP的概念

- Aspect Oriented Programing
  - 面向切面编程
- AOP是一种思想是对OOP的补充
  - AOP可以进一步提供编程的效率

![img](https://tva1.sinaimg.cn/large/0081Kckwgy1gkxuryoup6j31240u0466.jpg)

##### AOP的术语

![AOP术语](https://tva1.sinaimg.cn/large/0081Kckwgy1gkxv2ky9fkj31xo0u0dqo.jpg)

##### AOP的实现

- AspectJ
  - AspectJ是语言级的实现，它扩展了Java语言，定义了AOP语法
  - AspectJ在编译期织入代码，它有一个专门的编译器，用来生成遵守Java字节码规范的class文件
- Spring AOP
  - Spring AOP使用纯Java实现，它不需要专门的编译过程，也不需要特殊的类装载器
  - Spring AOP在运行时通过代理的方式织入代码，只支持方法类型的连接点
  -  Spring支持对AspectJ的集成

##### 动态代理

- JDK动态代理
  - Java提供的动态代理技术，可以在运行时创建接口的代理实例
  - Spring AOP默认采用此种方式，在接口代理实例中织入代码
- CGLib动态代理
  - 采用底层的字节码技术，在运行时创建子嘞代理实例
  - 当目标对象不存在接口时，Spring AOP会采用此种方式，在子类实例中织入代码



























































